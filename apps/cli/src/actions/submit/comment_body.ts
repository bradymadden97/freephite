import { TContext } from '../../lib/context';
import { TBranchPRInfo } from '../../lib/engine/metadata_ref';

export interface PR extends Required<Pick<TBranchPRInfo, 'number' | 'base'>> {
  ref: string;
}

type Ref = PR['ref'];
type Trunk = TContext['engine']['trunk'];
type Tree = Record<Ref | Trunk, Array<PR>>;
type Reverse = Record<Ref, Ref | Trunk>;

abstract class StackCommentBodyBase {
  protected tree: Tree;
  protected reverse: Reverse;
  protected comment: string;

  protected constructor(protected context: TContext, prs: Array<PR>) {
    this.tree = { [context.engine.trunk]: [] };
    this.reverse = {};

    // Populate tree with PR info
    for (const pr of prs) {
      this.addBranchToTree(pr);
    }

    // Fill the remaining path to trunk if necessary
    for (const base of Object.keys(this.tree)) {
      this.findRouteToTrunk(base);
    }

    this.comment = 'Current dependencies on/for this PR:\n\n';
    this.comment += this.buildTreeComment(undefined);
    this.comment += '\nThis comment was autogenerated by Freephite.';
  }

  protected buildPRString(pr: PR): string {
    return `**PR #${pr.number}**`;
  }

  private addBranchToTree(pr: PR) {
    const deps = this.tree[pr.base];
    this.tree[pr.base] = deps ? [...deps, pr] : [pr];
    this.tree[pr.ref] = this.tree[pr.ref] ?? [];
    this.reverse[pr.ref] = pr.base;
  }

  private findRouteToTrunk(base: string): void {
    if (base === this.context.engine.trunk) {
      return;
    }

    if (!(base in this.reverse)) {
      const pr = this.context.engine.getPrInfo(base);
      if (!pr?.number || !pr?.base) {
        return;
      }

      this.addBranchToTree({
        base: pr.base,
        number: pr.number,
        ref: base,
      });
    }

    return this.findRouteToTrunk(this.reverse[base]);
  }

  private buildTreeComment(pr: PR | undefined, level = 0): string {
    const trunk = this.context.engine.trunk;
    let line = ' '.repeat(level * 2) + '* ';
    if (pr === undefined) {
      line += `${trunk}:\n`;
    } else {
      line += this.buildPRString(pr) + '\n';
    }

    const children = pr === undefined ? this.tree[trunk] : this.tree[pr.ref];

    return line.concat(
      children.map((c) => this.buildTreeComment(c, level + 1)).join('')
    );
  }
}

/**
 * External API for generating a comment from a PR stack
 *
 * const body = StackCommentBody.generate(context: TContext, prs: Array<PR>)
 * const withPointer = body.forPR(pr: PR);
 *
 */
export class StackCommentBody extends StackCommentBodyBase {
  public static generate(context: TContext, prs: Array<PR>): StackCommentBody {
    return new this(context, prs);
  }

  public forPR(pr: PR): string {
    const line = this.buildPRString(pr);
    const index = this.comment.indexOf(line);

    return (
      this.comment.slice(0, index + line.length) +
      ' ðŸ‘ˆ' +
      this.comment.slice(index + line.length)
    );
  }

  public toString(): string {
    return this.comment;
  }
}
